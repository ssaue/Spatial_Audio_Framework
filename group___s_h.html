<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spatial_Audio_Framework: saf_sh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="CustomDoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spatial_Audio_Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___s_h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">saf_sh</div>  </div>
</div><!--header-->
<div class="contents">

<p>Spherical harmonic domain processing module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:saf__sh_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8c.html">saf_sh.c</a></td></tr>
<tr class="memdesc:saf__sh_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public source for the Spherical Harmonic Transform and Spherical Array Processing module (<a class="el" href="saf_8h.html#a4267176e3a1b83ff894c602e2af10025" title="SAF Module: SH.">SAF_SH_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__sh_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh_8h.html">saf_sh.h</a></td></tr>
<tr class="memdesc:saf__sh_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main header for the Spherical Harmonic Transform and Spherical Array Processing module (<a class="el" href="saf_8h.html#a4267176e3a1b83ff894c602e2af10025" title="SAF Module: SH.">SAF_SH_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__sh__internal_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh__internal_8c.html">saf_sh_internal.c</a></td></tr>
<tr class="memdesc:saf__sh__internal_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal source for the Spherical Harmonic Transform and Spherical Array Processing module (<a class="el" href="saf_8h.html#a4267176e3a1b83ff894c602e2af10025" title="SAF Module: SH.">SAF_SH_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:saf__sh__internal_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="saf__sh__internal_8h.html">saf_sh_internal.h</a></td></tr>
<tr class="memdesc:saf__sh__internal_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal header for the Spherical Harmonic Transform and Spherical Array Processing module (<a class="el" href="saf_8h.html#a4267176e3a1b83ff894c602e2af10025" title="SAF Module: SH.">SAF_SH_MODULE</a>) <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2bac5e4831e0699171545c1d38558d7e"><td class="memItemLeft" align="right" valign="top"><a id="ga2bac5e4831e0699171545c1d38558d7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga2bac5e4831e0699171545c1d38558d7e">ORDER2NSH</a>(order)&#160;&#160;&#160;((order+1)*(order+1))</td></tr>
<tr class="memdesc:ga2bac5e4831e0699171545c1d38558d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts spherical harmonic order to number of spherical harmonic components i.e: (order+1)^2. <br /></td></tr>
<tr class="separator:ga2bac5e4831e0699171545c1d38558d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dceeedc31e111954c34f6fc8d4880f0"><td class="memItemLeft" align="right" valign="top"><a id="ga1dceeedc31e111954c34f6fc8d4880f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga1dceeedc31e111954c34f6fc8d4880f0">NSH2ORDER</a>(nSH)&#160;&#160;&#160;( (int)(sqrt((double)nSH)-0.999) )</td></tr>
<tr class="memdesc:ga1dceeedc31e111954c34f6fc8d4880f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts number of spherical harmonic components to spherical harmonic order i.e: sqrt(nSH)-1. <br /></td></tr>
<tr class="separator:ga1dceeedc31e111954c34f6fc8d4880f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa2eb5bb4fefe6565eddd3f6ca862ba6b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> { <a class="el" href="group___s_h.html#ggaa2eb5bb4fefe6565eddd3f6ca862ba6baef2926e644b5529e6673d9af8cc5b0a1">ARRAY_CONSTRUCTION_OPEN</a>
, <a class="el" href="group___s_h.html#ggaa2eb5bb4fefe6565eddd3f6ca862ba6badd3f9c2386004df3244de2912dcdf496">ARRAY_CONSTRUCTION_OPEN_DIRECTIONAL</a>
, <a class="el" href="group___s_h.html#ggaa2eb5bb4fefe6565eddd3f6ca862ba6ba5b24de1a578a08282bebacdf03cefa7d">ARRAY_CONSTRUCTION_RIGID</a>
, <a class="el" href="group___s_h.html#ggaa2eb5bb4fefe6565eddd3f6ca862ba6ba046ccc1a8e502c8c952bb745def379b0">ARRAY_CONSTRUCTION_RIGID_DIRECTIONAL</a>
 }</td></tr>
<tr class="memdesc:gaa2eb5bb4fefe6565eddd3f6ca862ba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Microphone/Hydrophone array construction types.  <a href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">More...</a><br /></td></tr>
<tr class="separator:gaa2eb5bb4fefe6565eddd3f6ca862ba6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab457e2a01928e0357f12b00cdb6035c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a> { <a class="el" href="group___s_h.html#ggab457e2a01928e0357f12b00cdb6035c2a0ee77a29b6b553c6965108d240f99ff7">SECTOR_PATTERN_PWD</a>
, <a class="el" href="group___s_h.html#ggab457e2a01928e0357f12b00cdb6035c2a9024988fa2c043c931936b0e4fae3055">SECTOR_PATTERN_MAXRE</a>
, <a class="el" href="group___s_h.html#ggab457e2a01928e0357f12b00cdb6035c2aa419a9e82484c4077a49ab1a4bdbe30f">SECTOR_PATTERN_CARDIOID</a>
 }</td></tr>
<tr class="memdesc:gab457e2a01928e0357f12b00cdb6035c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector pattern designs for directionally-constraining sound-fields [1].  <a href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">More...</a><br /></td></tr>
<tr class="separator:gab457e2a01928e0357f12b00cdb6035c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1ff15ddf9e257b1f185421568ef349dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd">unnorm_legendreP</a> (int n, double *x, int lenX, double *y)</td></tr>
<tr class="memdesc:ga1ff15ddf9e257b1f185421568ef349dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1].  <a href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd">More...</a><br /></td></tr>
<tr class="separator:ga1ff15ddf9e257b1f185421568ef349dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3851842c7f6c520c3f645f0ae686443c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga3851842c7f6c520c3f645f0ae686443c">unnorm_legendreP_recur</a> (int n, float *x, int lenX, float *Pnm_minus1, float *Pnm_minus2, float *Pnm)</td></tr>
<tr class="memdesc:ga3851842c7f6c520c3f645f0ae686443c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates unnormalised Legendre polynomials up to order N, for all values in vector x.  <a href="group___s_h.html#ga3851842c7f6c520c3f645f0ae686443c">More...</a><br /></td></tr>
<tr class="separator:ga3851842c7f6c520c3f645f0ae686443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab8bc47f1068e8edd58e5d5c93a3fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gadab8bc47f1068e8edd58e5d5c93a3fa4">getSHreal</a> (int order, float *dirs_rad, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gadab8bc47f1068e8edd58e5d5c93a3fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.  <a href="group___s_h.html#gadab8bc47f1068e8edd58e5d5c93a3fa4">More...</a><br /></td></tr>
<tr class="separator:gadab8bc47f1068e8edd58e5d5c93a3fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4d86ed458c9fcdb13065c7e2f4c436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gabf4d86ed458c9fcdb13065c7e2f4c436">getSHreal_recur</a> (int order, float *dirs_rad, int nDirs, float *Y)</td></tr>
<tr class="memdesc:gabf4d86ed458c9fcdb13065c7e2f4c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.  <a href="group___s_h.html#gabf4d86ed458c9fcdb13065c7e2f4c436">More...</a><br /></td></tr>
<tr class="separator:gabf4d86ed458c9fcdb13065c7e2f4c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f83c48c3d7c7f20726512e0495cf4b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga4f83c48c3d7c7f20726512e0495cf4b9">getSHcomplex</a> (int order, float *dirs_rad, int nDirs, float_complex *Y)</td></tr>
<tr class="memdesc:ga4f83c48c3d7c7f20726512e0495cf4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes complex-valued spherical harmonics [1] for each given direction on the unit sphere.  <a href="group___s_h.html#ga4f83c48c3d7c7f20726512e0495cf4b9">More...</a><br /></td></tr>
<tr class="separator:ga4f83c48c3d7c7f20726512e0495cf4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf53b93c2ccb874ee75088b769fb387"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga8bf53b93c2ccb874ee75088b769fb387">complex2realSHMtx</a> (int order, float_complex *T_c2r)</td></tr>
<tr class="memdesc:ga8bf53b93c2ccb874ee75088b769fb387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a complex to real spherical harmonic transform matrix.  <a href="group___s_h.html#ga8bf53b93c2ccb874ee75088b769fb387">More...</a><br /></td></tr>
<tr class="separator:ga8bf53b93c2ccb874ee75088b769fb387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bf4d927842a9c97771801f2483b32d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gae1bf4d927842a9c97771801f2483b32d">real2complexSHMtx</a> (int order, float_complex *T_r2c)</td></tr>
<tr class="memdesc:gae1bf4d927842a9c97771801f2483b32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a real to complex spherical harmonic transform matrix.  <a href="group___s_h.html#gae1bf4d927842a9c97771801f2483b32d">More...</a><br /></td></tr>
<tr class="separator:gae1bf4d927842a9c97771801f2483b32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25c6081b6abb92ca3545a879b9996e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gaa25c6081b6abb92ca3545a879b9996e4">complex2realCoeffs</a> (int order, float_complex *C_N, int K, float *R_N)</td></tr>
<tr class="memdesc:gaa25c6081b6abb92ca3545a879b9996e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts SH coefficients from the complex to real basis.  <a href="group___s_h.html#gaa25c6081b6abb92ca3545a879b9996e4">More...</a><br /></td></tr>
<tr class="separator:gaa25c6081b6abb92ca3545a879b9996e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0681d04a190b7e1fe3d362f301f63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gabb0681d04a190b7e1fe3d362f301f63e">getSHrotMtxReal</a> (float R[3][3], float *RotMtx, int L)</td></tr>
<tr class="memdesc:gabb0681d04a190b7e1fe3d362f301f63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a real-valued spherical harmonic rotation matrix [1] based on a 3x3 rotation matrix (see <a class="el" href="group___utilities.html#ga2e80b68f78c7c6317073e603b6ed0b78" title="Constructs a 3x3 rotation matrix based on a quaternion.">quaternion2rotationMatrix()</a>, <a class="el" href="group___utilities.html#ga19a8e982f11eb0deaade1383781e179b" title="Constructs a 3x3 rotation matrix from the Euler angles.">euler2rotationMatrix()</a>)  <a href="group___s_h.html#gabb0681d04a190b7e1fe3d362f301f63e">More...</a><br /></td></tr>
<tr class="separator:gabb0681d04a190b7e1fe3d362f301f63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1a65a8f85a1505d0a96212775b4ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0">computeVelCoeffsMtx</a> (int sectorOrder, float_complex *A_xyz)</td></tr>
<tr class="memdesc:gacb1a65a8f85a1505d0a96212775b4ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that is essentially the product of a pattern of order=sectorOrder and a dipole.  <a href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0">More...</a><br /></td></tr>
<tr class="separator:gacb1a65a8f85a1505d0a96212775b4ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383baca216c2fa72fe1a7c5804133203"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga383baca216c2fa72fe1a7c5804133203">computeSectorCoeffsEP</a> (int orderSec, float_complex *A_xyz, <a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a> pattern, float *sec_dirs_deg, int nSecDirs, float *sectorCoeffs)</td></tr>
<tr class="memdesc:ga383baca216c2fa72fe1a7c5804133203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes beamforming matrices (sector coefficients) which, when applied to input SH signals, yield energy-preserving (EP) sectors.  <a href="group___s_h.html#ga383baca216c2fa72fe1a7c5804133203">More...</a><br /></td></tr>
<tr class="separator:ga383baca216c2fa72fe1a7c5804133203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e1b22dff2d98ed226851bbc2033144"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gad0e1b22dff2d98ed226851bbc2033144">computeSectorCoeffsAP</a> (int orderSec, float_complex *A_xyz, <a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a> pattern, float *sec_dirs_deg, int nSecDirs, float *sectorCoeffs)</td></tr>
<tr class="memdesc:gad0e1b22dff2d98ed226851bbc2033144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes beamforming matrices (sector coefficients) which, when applied to input SH signals, yield amplitude-preserving (EP) sectors.  <a href="group___s_h.html#gad0e1b22dff2d98ed226851bbc2033144">More...</a><br /></td></tr>
<tr class="separator:gad0e1b22dff2d98ed226851bbc2033144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga7ad01934dabcf7a8f8b08bcdd4439fe3">beamWeightsCardioid2Spherical</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:ga7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for generating cardioid beampatterns.  <a href="group___s_h.html#ga7ad01934dabcf7a8f8b08bcdd4439fe3">More...</a><br /></td></tr>
<tr class="separator:ga7ad01934dabcf7a8f8b08bcdd4439fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f95b52193c9d94633463106c86cb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga45f95b52193c9d94633463106c86cb63">beamWeightsDolphChebyshev2Spherical</a> (int N, int paramType, float arrayParam, float *b_n)</td></tr>
<tr class="memdesc:ga45f95b52193c9d94633463106c86cb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for Dolph-Chebyshev beampatterns, with mainlobe and sidelobe control [1].  <a href="group___s_h.html#ga45f95b52193c9d94633463106c86cb63">More...</a><br /></td></tr>
<tr class="separator:ga45f95b52193c9d94633463106c86cb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce9116273f897fe0ecf9b46d580be48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga9ce9116273f897fe0ecf9b46d580be48">beamWeightsHypercardioid2Spherical</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:ga9ce9116273f897fe0ecf9b46d580be48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for hypercardioid beampatterns.  <a href="group___s_h.html#ga9ce9116273f897fe0ecf9b46d580be48">More...</a><br /></td></tr>
<tr class="separator:ga9ce9116273f897fe0ecf9b46d580be48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c35ba6af7f1f13e53ee473bb622398b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga7c35ba6af7f1f13e53ee473bb622398b">beamWeightsMaxEV</a> (int N, float *b_n)</td></tr>
<tr class="memdesc:ga7c35ba6af7f1f13e53ee473bb622398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamweights in the SHD for maximum energy-vector beampatterns.  <a href="group___s_h.html#ga7c35ba6af7f1f13e53ee473bb622398b">More...</a><br /></td></tr>
<tr class="separator:ga7c35ba6af7f1f13e53ee473bb622398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fcf376f908a5403bc31989ac986ab78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga4fcf376f908a5403bc31989ac986ab78">beamWeightsVelocityPatternsReal</a> (int order, float *b_n, float azi_rad, float elev_rad, float_complex *A_xyz, float *velCoeffs)</td></tr>
<tr class="memdesc:ga4fcf376f908a5403bc31989ac986ab78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamforming coefficients for velocity patterns (REAL)  <a href="group___s_h.html#ga4fcf376f908a5403bc31989ac986ab78">More...</a><br /></td></tr>
<tr class="separator:ga4fcf376f908a5403bc31989ac986ab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6077cbef3c4d075dd47e833f9675ae37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga6077cbef3c4d075dd47e833f9675ae37">beamWeightsVelocityPatternsComplex</a> (int order, float *b_n, float azi_rad, float elev_rad, float_complex *A_xyz, float_complex *velCoeffs)</td></tr>
<tr class="memdesc:ga6077cbef3c4d075dd47e833f9675ae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates beamforming coefficients for velocity patterns (COMPLEX)  <a href="group___s_h.html#ga6077cbef3c4d075dd47e833f9675ae37">More...</a><br /></td></tr>
<tr class="separator:ga6077cbef3c4d075dd47e833f9675ae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824b11467b1f54b0725264b256f6a193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga824b11467b1f54b0725264b256f6a193">rotateAxisCoeffsReal</a> (int order, float *c_n, float theta_0, float phi_0, float *c_nm)</td></tr>
<tr class="memdesc:ga824b11467b1f54b0725264b256f6a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for a rotated axisymmetric pattern (REAL)  <a href="group___s_h.html#ga824b11467b1f54b0725264b256f6a193">More...</a><br /></td></tr>
<tr class="separator:ga824b11467b1f54b0725264b256f6a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga266a06c6c96240add2d3ab171d89925d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga266a06c6c96240add2d3ab171d89925d">rotateAxisCoeffsComplex</a> (int order, float *c_n, float theta_0, float phi_0, float_complex *c_nm)</td></tr>
<tr class="memdesc:ga266a06c6c96240add2d3ab171d89925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates spherical coefficients for a rotated axisymmetric pattern (COMPLEX)  <a href="group___s_h.html#ga266a06c6c96240add2d3ab171d89925d">More...</a><br /></td></tr>
<tr class="separator:ga266a06c6c96240add2d3ab171d89925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd7fa820cb691a376c70ca33e1c77743"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gadd7fa820cb691a376c70ca33e1c77743">checkCondNumberSHTReal</a> (int order, float *dirs_rad, int nDirs, float *w, float *cond_N)</td></tr>
<tr class="memdesc:gadd7fa820cb691a376c70ca33e1c77743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the condition numbers for a least-squares SHT.  <a href="group___s_h.html#gadd7fa820cb691a376c70ca33e1c77743">More...</a><br /></td></tr>
<tr class="separator:gadd7fa820cb691a376c70ca33e1c77743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf0a400072210fcc5613918008c03ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga2bf0a400072210fcc5613918008c03ce">sphPWD_create</a> (void **const phPWD, int order, float *grid_dirs_deg, int nDirs)</td></tr>
<tr class="memdesc:ga2bf0a400072210fcc5613918008c03ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of a spherical harmonic domain implementation of the steer-response power (SRP) approach for computing power-maps, which can then be used for sound-field visualisation/DoA estimation purposes.  <a href="group___s_h.html#ga2bf0a400072210fcc5613918008c03ce">More...</a><br /></td></tr>
<tr class="separator:ga2bf0a400072210fcc5613918008c03ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804a98cd6ebe9775cfe1447c9d2f24e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga804a98cd6ebe9775cfe1447c9d2f24e8">sphPWD_destroy</a> (void **const phPWD)</td></tr>
<tr class="memdesc:ga804a98cd6ebe9775cfe1447c9d2f24e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the spherical harmonic domain PWD implementation.  <a href="group___s_h.html#ga804a98cd6ebe9775cfe1447c9d2f24e8">More...</a><br /></td></tr>
<tr class="separator:ga804a98cd6ebe9775cfe1447c9d2f24e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff25c089ba08c1fa24588ac2c3847d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga8ff25c089ba08c1fa24588ac2c3847d6">sphPWD_compute</a> (void *const hPWD, float_complex *Cx, int nSrcs, float *P_map, int *peak_inds)</td></tr>
<tr class="memdesc:ga8ff25c089ba08c1fa24588ac2c3847d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a power-map based on determining the energy of hyper-cardioid beamformers; optionally, also returning the grid indices corresponding to the N highest peaks (N=nSrcs)  <a href="group___s_h.html#ga8ff25c089ba08c1fa24588ac2c3847d6">More...</a><br /></td></tr>
<tr class="separator:ga8ff25c089ba08c1fa24588ac2c3847d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5795da6a1c9ddc4e8da449c3dfc5da7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga5795da6a1c9ddc4e8da449c3dfc5da7d">sphMUSIC_create</a> (void **const phMUSIC, int order, float *grid_dirs_deg, int nDirs)</td></tr>
<tr class="memdesc:ga5795da6a1c9ddc4e8da449c3dfc5da7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the spherical harmonic domain MUSIC implementation, which may be used for computing pseudo-spectrums for visualisation/DoA estimation purposes.  <a href="group___s_h.html#ga5795da6a1c9ddc4e8da449c3dfc5da7d">More...</a><br /></td></tr>
<tr class="separator:ga5795da6a1c9ddc4e8da449c3dfc5da7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d297fcc1391d5771694a2db578ad94f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga1d297fcc1391d5771694a2db578ad94f">sphMUSIC_destroy</a> (void **const phMUSIC)</td></tr>
<tr class="memdesc:ga1d297fcc1391d5771694a2db578ad94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the spherical harmonic domain MUSIC implementation.  <a href="group___s_h.html#ga1d297fcc1391d5771694a2db578ad94f">More...</a><br /></td></tr>
<tr class="separator:ga1d297fcc1391d5771694a2db578ad94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a05324e0f65f141dc8df7578a1521d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga36a05324e0f65f141dc8df7578a1521d">sphMUSIC_compute</a> (void *const hMUSIC, float_complex *Vn, int nSrcs, float *P_music, int *peak_inds)</td></tr>
<tr class="memdesc:ga36a05324e0f65f141dc8df7578a1521d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pseudo-spectrum based on the MUSIC algorithm in the spherical harmonic domain; optionally returning the grid indices corresponding to the N highest peaks (N=nSrcs)  <a href="group___s_h.html#ga36a05324e0f65f141dc8df7578a1521d">More...</a><br /></td></tr>
<tr class="separator:ga36a05324e0f65f141dc8df7578a1521d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37dbabb094421f7d62d3bdf7639994e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga37dbabb094421f7d62d3bdf7639994e4">sphESPRIT_create</a> (void **const phESPRIT, int order)</td></tr>
<tr class="memdesc:ga37dbabb094421f7d62d3bdf7639994e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the spherical harmonic domain ESPRIT-based direction of arrival estimator.  <a href="group___s_h.html#ga37dbabb094421f7d62d3bdf7639994e4">More...</a><br /></td></tr>
<tr class="separator:ga37dbabb094421f7d62d3bdf7639994e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bf00932a6a3dc9e1b87fa0153f1f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gab2bf00932a6a3dc9e1b87fa0153f1f55">sphESPRIT_destroy</a> (void **const phESPRIT)</td></tr>
<tr class="memdesc:gab2bf00932a6a3dc9e1b87fa0153f1f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the spherical harmonic domain ESPRIT-based direction of arrival estimator.  <a href="group___s_h.html#gab2bf00932a6a3dc9e1b87fa0153f1f55">More...</a><br /></td></tr>
<tr class="separator:gab2bf00932a6a3dc9e1b87fa0153f1f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691b6b170ac22906adbc08c8b27a2418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga691b6b170ac22906adbc08c8b27a2418">sphESPRIT_estimateDirs</a> (void *const hESPRIT, float_complex *Us, int K, float *src_dirs_rad)</td></tr>
<tr class="memdesc:ga691b6b170ac22906adbc08c8b27a2418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the direction-of-arrival (DoA) based on the ESPRIT-based estimator, in the spherical harmonic domain.  <a href="group___s_h.html#ga691b6b170ac22906adbc08c8b27a2418">More...</a><br /></td></tr>
<tr class="separator:ga691b6b170ac22906adbc08c8b27a2418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b1194ee375caef234c1302fddce718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gac6b1194ee375caef234c1302fddce718">generatePWDmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float *pmap)</td></tr>
<tr class="memdesc:gac6b1194ee375caef234c1302fddce718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a powermap based on the energy of a plane-wave decomposition (PWD) (i.e.  <a href="group___s_h.html#gac6b1194ee375caef234c1302fddce718">More...</a><br /></td></tr>
<tr class="separator:gac6b1194ee375caef234c1302fddce718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a623080053b63c3a918485dcba3e084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga0a623080053b63c3a918485dcba3e084">generateMVDRmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float regPar, float *pmap, float_complex *w_MVDR)</td></tr>
<tr class="memdesc:ga0a623080053b63c3a918485dcba3e084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a powermap based on the energy of adaptive Minimum-Variance Distortion-less Response (MVDR) beamformers.  <a href="group___s_h.html#ga0a623080053b63c3a918485dcba3e084">More...</a><br /></td></tr>
<tr class="separator:ga0a623080053b63c3a918485dcba3e084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa06c99cc4846f8c2148a93db9086e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gafa06c99cc4846f8c2148a93db9086e54">generateCroPaCLCMVmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nGrid_dirs, float regPar, float lambda, float *pmap)</td></tr>
<tr class="memdesc:gafa06c99cc4846f8c2148a93db9086e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">(EXPERIMENTAL) Generates a powermap utilising the CroPaC LCMV post-filter described in [1]  <a href="group___s_h.html#gafa06c99cc4846f8c2148a93db9086e54">More...</a><br /></td></tr>
<tr class="separator:gafa06c99cc4846f8c2148a93db9086e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c430bacc593f41dbc7b0b1ba6c912cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga9c430bacc593f41dbc7b0b1ba6c912cd">generateMUSICmap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nSources, int nGrid_dirs, int logScaleFlag, float *pmap)</td></tr>
<tr class="memdesc:ga9c430bacc593f41dbc7b0b1ba6c912cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an activity-map based on the sub-space multiple-signal classification (MUSIC) method.  <a href="group___s_h.html#ga9c430bacc593f41dbc7b0b1ba6c912cd">More...</a><br /></td></tr>
<tr class="separator:ga9c430bacc593f41dbc7b0b1ba6c912cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga08d3bc0f9e750716e3fb73c1c3aafe6e">generateMinNormMap</a> (int order, float_complex *Cx, float_complex *Y_grid, int nSources, int nGrid_dirs, int logScaleFlag, float *pmap)</td></tr>
<tr class="memdesc:ga08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an activity-map based on the sub-space minimum-norm (MinNorm) method.  <a href="group___s_h.html#ga08d3bc0f9e750716e3fb73c1c3aafe6e">More...</a><br /></td></tr>
<tr class="separator:ga08d3bc0f9e750716e3fb73c1c3aafe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c63d4e98e234ed80ba8eca7f939b653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga2c63d4e98e234ed80ba8eca7f939b653">cylModalCoeffs</a> (int order, double *kr, int nBands, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double_complex *b_N)</td></tr>
<tr class="memdesc:ga2c63d4e98e234ed80ba8eca7f939b653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for open/rigid cylindrical arrays.  <a href="group___s_h.html#ga2c63d4e98e234ed80ba8eca7f939b653">More...</a><br /></td></tr>
<tr class="separator:ga2c63d4e98e234ed80ba8eca7f939b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898eab67c2144d794201bbc80c2c6aa2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga898eab67c2144d794201bbc80c2c6aa2">sphArrayAliasLim</a> (float r, float c, int maxN)</td></tr>
<tr class="memdesc:ga898eab67c2144d794201bbc80c2c6aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a simple estimate of the spatial aliasing limit (the kR = maxN rule)  <a href="group___s_h.html#ga898eab67c2144d794201bbc80c2c6aa2">More...</a><br /></td></tr>
<tr class="separator:ga898eab67c2144d794201bbc80c2c6aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9774e448be3d0caf15ce45077d0d5ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga9774e448be3d0caf15ce45077d0d5ebe">sphArrayNoiseThreshold</a> (int maxN, int Nsensors, float r, float c, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, float maxG_db, float *f_lim)</td></tr>
<tr class="memdesc:ga9774e448be3d0caf15ce45077d0d5ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the frequencies (per order), at which the noise of a SHT of a SMA exceeds a specified maximum level.  <a href="group___s_h.html#ga9774e448be3d0caf15ce45077d0d5ebe">More...</a><br /></td></tr>
<tr class="separator:ga9774e448be3d0caf15ce45077d0d5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c331fd73b56845ab0ecbf4b0d5fc640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga6c331fd73b56845ab0ecbf4b0d5fc640">sphModalCoeffs</a> (int order, double *kr, int nBands, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, double_complex *b_N)</td></tr>
<tr class="memdesc:ga6c331fd73b56845ab0ecbf4b0d5fc640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for open/rigid spherical arrays.  <a href="group___s_h.html#ga6c331fd73b56845ab0ecbf4b0d5fc640">More...</a><br /></td></tr>
<tr class="separator:ga6c331fd73b56845ab0ecbf4b0d5fc640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc74c9714841c3f48974fe10e6485eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gadc74c9714841c3f48974fe10e6485eea">sphScattererModalCoeffs</a> (int order, double *kr, double *kR, int nBands, double_complex *b_N)</td></tr>
<tr class="memdesc:gadc74c9714841c3f48974fe10e6485eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for a rigid spherical scatterer with omni-directional sensors.  <a href="group___s_h.html#gadc74c9714841c3f48974fe10e6485eea">More...</a><br /></td></tr>
<tr class="separator:gadc74c9714841c3f48974fe10e6485eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedc488e33c0239baebed8cd7aeabd8a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gaedc488e33c0239baebed8cd7aeabd8a7">sphScattererDirModalCoeffs</a> (int order, double *kr, double *kR, int nBands, double dirCoeff, double_complex *b_N)</td></tr>
<tr class="memdesc:gaedc488e33c0239baebed8cd7aeabd8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the modal coefficients for a rigid spherical scatterer with directional sensors.  <a href="group___s_h.html#gaedc488e33c0239baebed8cd7aeabd8a7">More...</a><br /></td></tr>
<tr class="separator:gaedc488e33c0239baebed8cd7aeabd8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfb43c7f737a1f030ebe471272e7c04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gadbfb43c7f737a1f030ebe471272e7c04">sphDiffCohMtxTheory</a> (int order, float *sensor_dirs_rad, int N_sensors, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, double *kr, int nBands, double *M_diffcoh)</td></tr>
<tr class="memdesc:gadbfb43c7f737a1f030ebe471272e7c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the theoretical diffuse coherence matrix for a spherical array.  <a href="group___s_h.html#gadbfb43c7f737a1f030ebe471272e7c04">More...</a><br /></td></tr>
<tr class="separator:gadbfb43c7f737a1f030ebe471272e7c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5203b16cf67ef27b422078d20618863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gaa5203b16cf67ef27b422078d20618863">simulateCylArray</a> (int order, double *kr, int nBands, float *sensor_dirs_rad, int N_sensors, float *src_dirs_deg, int N_srcs, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, float_complex *H_array)</td></tr>
<tr class="memdesc:gaa5203b16cf67ef27b422078d20618863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a cylindrical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the cylinder.  <a href="group___s_h.html#gaa5203b16cf67ef27b422078d20618863">More...</a><br /></td></tr>
<tr class="separator:gaa5203b16cf67ef27b422078d20618863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4fe5085d4cc6223772f6e49ef74f355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#gab4fe5085d4cc6223772f6e49ef74f355">simulateSphArray</a> (int order, double *kr, double *kR, int nBands, float *sensor_dirs_rad, int N_sensors, float *src_dirs_deg, int N_srcs, <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a> arrayType, double dirCoeff, float_complex *H_array)</td></tr>
<tr class="memdesc:gab4fe5085d4cc6223772f6e49ef74f355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates a spherical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the sphere.  <a href="group___s_h.html#gab4fe5085d4cc6223772f6e49ef74f355">More...</a><br /></td></tr>
<tr class="separator:gab4fe5085d4cc6223772f6e49ef74f355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7f439e15ed96ccf49617ba763ca4b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_h.html#ga2e7f439e15ed96ccf49617ba763ca4b6">evaluateSHTfilters</a> (int order, float_complex *M_array2SH, int nSensors, int nBands, float_complex *H_array, int nDirs, float_complex *Y_grid, float *cSH, float *lSH)</td></tr>
<tr class="memdesc:ga2e7f439e15ed96ccf49617ba763ca4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates some objective measures, which evaluate the performance of spatial encoding filters.  <a href="group___s_h.html#ga2e7f439e15ed96ccf49617ba763ca4b6">More...</a><br /></td></tr>
<tr class="separator:ga2e7f439e15ed96ccf49617ba763ca4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Spherical harmonic domain processing module. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa2eb5bb4fefe6565eddd3f6ca862ba6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">&#9670;&nbsp;</a></span>ARRAY_CONSTRUCTION_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Microphone/Hydrophone array construction types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa2eb5bb4fefe6565eddd3f6ca862ba6baef2926e644b5529e6673d9af8cc5b0a1"></a>ARRAY_CONSTRUCTION_OPEN&#160;</td><td class="fielddoc"><p>Open array, omni-directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2eb5bb4fefe6565eddd3f6ca862ba6badd3f9c2386004df3244de2912dcdf496"></a>ARRAY_CONSTRUCTION_OPEN_DIRECTIONAL&#160;</td><td class="fielddoc"><p>Open array, directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2eb5bb4fefe6565eddd3f6ca862ba6ba5b24de1a578a08282bebacdf03cefa7d"></a>ARRAY_CONSTRUCTION_RIGID&#160;</td><td class="fielddoc"><p>Rigid baffle, omni-directional sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa2eb5bb4fefe6565eddd3f6ca862ba6ba046ccc1a8e502c8c952bb745def379b0"></a>ARRAY_CONSTRUCTION_RIGID_DIRECTIONAL&#160;</td><td class="fielddoc"><p>Rigid baffle, directional sensors. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__sh_8h_source.html#l00061">61</a> of file <a class="el" href="saf__sh_8h_source.html">saf_sh.h</a>.</p>

</div>
</div>
<a id="gab457e2a01928e0357f12b00cdb6035c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab457e2a01928e0357f12b00cdb6035c2">&#9670;&nbsp;</a></span>SECTOR_PATTERNS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sector pattern designs for directionally-constraining sound-fields [1]. </p>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., &amp; Pulkki, V. (2016). Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab457e2a01928e0357f12b00cdb6035c2a0ee77a29b6b553c6965108d240f99ff7"></a>SECTOR_PATTERN_PWD&#160;</td><td class="fielddoc"><p>Plane-wave decomposition/Hyper-cardioid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab457e2a01928e0357f12b00cdb6035c2a9024988fa2c043c931936b0e4fae3055"></a>SECTOR_PATTERN_MAXRE&#160;</td><td class="fielddoc"><p>Spatially tapered hyper-cardioid, such that it has maximum energy concentrated in the look- direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab457e2a01928e0357f12b00cdb6035c2aa419a9e82484c4077a49ab1a4bdbe30f"></a>SECTOR_PATTERN_CARDIOID&#160;</td><td class="fielddoc"><p>Cardioid pattern. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="saf__sh_8h_source.html#l00078">78</a> of file <a class="el" href="saf__sh_8h_source.html">saf_sh.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7ad01934dabcf7a8f8b08bcdd4439fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ad01934dabcf7a8f8b08bcdd4439fe3">&#9670;&nbsp;</a></span>beamWeightsCardioid2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsCardioid2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for generating cardioid beampatterns. </p>
<p>For a specific order N of a higher order cardioid of the form D(theta)=(1/2)^N * (1+cos(theta))^N, this function generates the beamweights for the same pattern, but in the SHD. Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00703">703</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga45f95b52193c9d94633463106c86cb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f95b52193c9d94633463106c86cb63">&#9670;&nbsp;</a></span>beamWeightsDolphChebyshev2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsDolphChebyshev2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>paramType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrayParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for Dolph-Chebyshev beampatterns, with mainlobe and sidelobe control [1]. </p>
<p>Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="section warning"><dt>Warning</dt><dd>NOT IMPLEMENTED YET!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramType</td><td>'0' side-lobe level control, '1' mainlobe width control </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayParam</td><td>Sidelobe level 1/R or mainlobe with 2*a0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Koretz, A. and Rafaely, B., 2009. Dolph-Chebyshev beampattern design for spherical arrays. IEEE Transactions on Signal Processing, 57(6), pp.2417-2420. </dd></dl>

</div>
</div>
<a id="ga9ce9116273f897fe0ecf9b46d580be48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce9116273f897fe0ecf9b46d580be48">&#9670;&nbsp;</a></span>beamWeightsHypercardioid2Spherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsHypercardioid2Spherical </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for hypercardioid beampatterns. </p>
<p>The hypercardioid is the pattern that maximises the directivity-factor for a certain SH order (N). The hypercardioid is also the plane-wave decomposition beamformer in the SHD, also called 'regular' because the beamweights are just the SH values on the beam-direction. Since the pattern is axisymmetric only the N+1 coefficients of m=0 are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00720">720</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga7c35ba6af7f1f13e53ee473bb622398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c35ba6af7f1f13e53ee473bb622398b">&#9670;&nbsp;</a></span>beamWeightsMaxEV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsMaxEV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamweights in the SHD for maximum energy-vector beampatterns. </p>
<p>Generate the beamweights for the a maximum energy-vector beampattern in the SHD. This pattern originates from Ambisonic-related research as it maximises the ambisonic energy-vector, which is essentially the directional centroid of the squared pattern. It can also be seen as the pattern which maximizes the acoustic intensity vector of a diffuse field weighted with this pattern. In practice it is almost the same as a supercardioid which maximizes front- back power ratio for a certain order, and it can be used as such. Because the pattern is axisymmetric only the N+1 coefficients of m=0 are returned. Details for their theory can be found, for example, in [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_n</td><td>Beamformer weights; (N+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Zotter, F., Pomberger, H. and Noisternig, M., 2012. Energy- preserving ambisonic decoding. Acta Acustica united with Acustica, 98(1), pp.37-47. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00738">738</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga6077cbef3c4d075dd47e833f9675ae37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6077cbef3c4d075dd47e833f9675ae37">&#9670;&nbsp;</a></span>beamWeightsVelocityPatternsComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsVelocityPatternsComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>velCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamforming coefficients for velocity patterns (COMPLEX) </p>
<p>If the sound-field is weighted with an axisymmetric spatial distribution described by the N+1 SH coefficients b_n, then the beamweights capturing the velocity signals for the weighted sound-field are of an order one higher than the weighting pattern, and can be derived from it. This type of beamforming has some applications for spatial sound reproduction and acoustic analysis, see [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_n</td><td>Axisymmetric beamformer weights; (order+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi_rad</td><td>Orientation, azimuth in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elev_rad</td><td>Orientation, ELEVATION in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients; see <a class="el" href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0" title="Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that ...">computeVelCoeffsMtx()</a>; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">velCoeffs</td><td>Beamforming coefficients for velocity patterns; FLAT: (order+2)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00786">786</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga4fcf376f908a5403bc31989ac986ab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fcf376f908a5403bc31989ac986ab78">&#9670;&nbsp;</a></span>beamWeightsVelocityPatternsReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void beamWeightsVelocityPatternsReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>b_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>azi_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>elev_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>velCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates beamforming coefficients for velocity patterns (REAL) </p>
<p>If the sound-field is weighted with an axisymmetric spatial distribution described by the N+1 SH coefficients b_n, then the beamweights capturing the velocity signals for the weighted sound-field are of an order one higher than the weighting pattern, and can be derived from it. This type of beamforming has some applications for spatial sound reproduction and acoustic analysis, see [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_n</td><td>Axisymmetric beamformer weights; (order+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">azi_rad</td><td>Orientation, azimuth in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elev_rad</td><td>Orientation, ELEVATION in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients; see <a class="el" href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0" title="Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that ...">computeVelCoeffsMtx()</a>; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">velCoeffs</td><td>Beamforming coefficients for velocity patterns; FLAT: (order+2)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00765">765</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gadd7fa820cb691a376c70ca33e1c77743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd7fa820cb691a376c70ca33e1c77743">&#9670;&nbsp;</a></span>checkCondNumberSHTReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkCondNumberSHTReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cond_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the condition numbers for a least-squares SHT. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000018">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#aa8b8eef199b8983d3b18cbf453fc2cf0" title="Testing that for T-designs, the condition numbers are all equal to 1.">test__checkCondNumberSHTReal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Integration weights; nDirs x 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_N</td><td>Condition numbers; (order+1) x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00871">871</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gaa25c6081b6abb92ca3545a879b9996e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25c6081b6abb92ca3545a879b9996e4">&#9670;&nbsp;</a></span>complex2realCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void complex2realCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>C_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>R_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts SH coefficients from the complex to real basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C_N</td><td>Complex coeffients; FLAT: (order+1)^2 x K </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Number of columns </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R_N</td><td>Real coefficients; FLAT: (order+1)^2 x K </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00445">445</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga8bf53b93c2ccb874ee75088b769fb387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf53b93c2ccb874ee75088b769fb387">&#9670;&nbsp;</a></span>complex2realSHMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void complex2realSHMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>T_c2r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a complex to real spherical harmonic transform matrix. </p>
<p>Computes the unitary transformation matrix T_c2r. It expresses the real spherical harmonics with respect to the complex harmonics, so that r_N = T_c2r * y_N, where r_N and y_N is are the real and complex SH vectors, respectively.</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000013">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#aa287f898d7c0f64e7823c09bc11824fa" title="Testing the complex to real spherical harmonic conversion, using getSHreal() as the reference.">test__complex2realSHMtx()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T_c2r</td><td>Transformation matrix for complex-&gt;real; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00381">381</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gad0e1b22dff2d98ed226851bbc2033144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e1b22dff2d98ed226851bbc2033144">&#9670;&nbsp;</a></span>computeSectorCoeffsAP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float computeSectorCoeffsAP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sec_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sectorCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes beamforming matrices (sector coefficients) which, when applied to input SH signals, yield amplitude-preserving (EP) sectors. </p>
<p>This partitioning of the sound-field into spatially-localised sectors has been used e.g. for parametric sound-field reproduction in [1] and visualisation in [2,3].</p>
<dl class="section note"><dt>Note</dt><dd>Each sector comprises 1x sector pattern of order "orderSec", and 3x weighted dipoles which are essentially the product of the sector pattern with (unweighted) dipoles, and have the directivity of one higher order (orderSec+1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">orderSec</td><td>Order of sector patterns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients, see <a class="el" href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0" title="Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that ...">computeVelCoeffsMtx()</a>; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>See <a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2" title="Sector pattern designs for directionally-constraining sound-fields [1].">SECTOR_PATTERNS</a> enum for the options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_dirs_deg</td><td>Sector directions [azi elev], in DEGREES; FLAT: nSecDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSecDirs</td><td>Number of sectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sectorCoeffs</td><td>The sector coefficients; FLAT: (nSecDirs*4) x (orderSec+2)^2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalisation coefficient</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., Vilkamo, J., &amp; Pulkki, V. (2015). Sector-based parametric sound field reproduction in the spherical harmonic domain. IEEE Journal of Selected Topics in Signal Processing, 9(5), 852-866. </dd>
<dd>
[2] McCormack, L., Politis, A., and Pulkki, V. (2019). "Sharpening of angular spectra based on a directional re-assignment approach for ambisonic sound-field visualisation". IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP). </dd>
<dd>
[3] McCormack, L., Delikaris-Manias, S., Politis, A., Pavlidi, D., Farina, A., Pinardi, D. and Pulkki, V., 2019. Applications of Spatially Localized Active-Intensity Vectors for Sound-Field Visualization. Journal of the Audio Engineering Society, 67(11), pp.840-854. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00650">650</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga383baca216c2fa72fe1a7c5804133203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383baca216c2fa72fe1a7c5804133203">&#9670;&nbsp;</a></span>computeSectorCoeffsEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float computeSectorCoeffsEP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orderSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2">SECTOR_PATTERNS</a>&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sec_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sectorCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes beamforming matrices (sector coefficients) which, when applied to input SH signals, yield energy-preserving (EP) sectors. </p>
<p>This partitioning of the sound-field into spatially-localised sectors has been used e.g. for parametric sound-field reproduction in [1] and visualisation in [2,3].</p>
<dl class="section note"><dt>Note</dt><dd>Each sector comprises 1x sector pattern of order "orderSec", and 3x weighted dipoles which are essentially the product of the sector pattern with (unweighted) dipoles, and have the directivity of one higher order (orderSec+1).</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000017">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#aa313ae6eb64e8ab4db6b5482882ac348" title="Testing the computeSectorCoeffsEP() and computeVelCoeffsMtx() functions and comparing their output to...">test__computeSectorCoeffsEP()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">orderSec</td><td>Order of sector patterns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_xyz</td><td>Velocity coefficients, see <a class="el" href="group___s_h.html#gacb1a65a8f85a1505d0a96212775b4ae0" title="Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that ...">computeVelCoeffsMtx()</a>; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>See <a class="el" href="group___s_h.html#gab457e2a01928e0357f12b00cdb6035c2" title="Sector pattern designs for directionally-constraining sound-fields [1].">SECTOR_PATTERNS</a> enum for the options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_dirs_deg</td><td>Sector directions [azi elev], in DEGREES; FLAT: nSecDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSecDirs</td><td>Number of sectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sectorCoeffs</td><td>The sector coefficients; FLAT: (nSecDirs*4) x (orderSec+2)^2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalisation coefficient</dd></dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., Vilkamo, J., &amp; Pulkki, V. (2015). Sector-based parametric sound field reproduction in the spherical harmonic domain. IEEE Journal of Selected Topics in Signal Processing, 9(5), 852-866. </dd>
<dd>
[2] McCormack, L., Politis, A., and Pulkki, V. (2019). "Sharpening of angular spectra based on a directional re-assignment approach for ambisonic sound-field visualisation". IEEE International Conference ' on Acoustics, Speech and Signal Processing (ICASSP). </dd>
<dd>
[3] McCormack, L., Delikaris-Manias, S., Politis, A., Pavlidi, D., Farina, A., Pinardi, D. and Pulkki, V., 2019. Applications of Spatially Localized Active-Intensity Vectors for Sound-Field Visualization. Journal of the Audio Engineering Society, 67(11), pp.840-854. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00584">584</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gacb1a65a8f85a1505d0a96212775b4ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb1a65a8f85a1505d0a96212775b4ae0">&#9670;&nbsp;</a></span>computeVelCoeffsMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeVelCoeffsMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sectorOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>A_xyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the matrices which generate the coefficients of a beampattern of order (sectorOrder+1) that is essentially the product of a pattern of order=sectorOrder and a dipole. </p>
<p>It is used in beamWeightsVelocityPatterns(). For a derivation of the matrices refer to [1].</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000016">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#aa313ae6eb64e8ab4db6b5482882ac348" title="Testing the computeSectorCoeffsEP() and computeVelCoeffsMtx() functions and comparing their output to...">test__computeSectorCoeffsEP()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sectorOrder</td><td>Order of patterns </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_xyz</td><td>Velocity coefficients; FLAT: (sectorOrder+2)^2 x (sectorOrder+1)^2 x 3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A. and Pulkki, V., 2016. Acoustic intensity, energy-density and diffuseness estimation in a directionally-constrained region. arXiv preprint arXiv:1609.03409 </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00552">552</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga2c63d4e98e234ed80ba8eca7f939b653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c63d4e98e234ed80ba8eca7f939b653">&#9670;&nbsp;</a></span>cylModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cylModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for open/rigid cylindrical arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01765">1765</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga2e7f439e15ed96ccf49617ba763ca4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7f439e15ed96ccf49617ba763ca4b6">&#9670;&nbsp;</a></span>evaluateSHTfilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evaluateSHTfilters </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>M_array2SH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>cSH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lSH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates some objective measures, which evaluate the performance of spatial encoding filters. </p>
<p>This analysis is performed by comparing the spatial resolution of the spherical harmonic components generated by the encoding filters, with the ideal SH components. For more information, the reader is directed to [1,2].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Transform/encoding order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_array2SH</td><td>Encoding matrix per frequency; FLAT: nBands x (order+1)^2 x nSensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H_array</td><td>Measured/modelled array responses for many directions; FLAT: nBands x nSensors x nDirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions the array was measured/modelled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Spherical harmonics weights for each grid direction; FLAT: nDirs x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cSH</td><td>Absolute values of the spatial correlation per band and order; FLAT: nBands x (order+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lSH</td><td>Level difference per band and order; FLAT: nBands x (order+1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Moreau, S., Daniel, J., Bertet, S., 2006, 3D sound field recording with higher order ambisonics&ndash;objective measurements and validation of spherical microphone. In Audio Engineering Society Convention 120. </dd>
<dd>
[2] Politis, A., Gamper, H. (2017). "Comparing Modelled And Measurement- Based Spherical Harmonic Encoding Filters For Spherical Microphone Arrays. In IEEE Workshop on Applications of Signal Processing to Audio and Acoustics (WASPAA). </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l02275">2275</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gafa06c99cc4846f8c2148a93db9086e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa06c99cc4846f8c2148a93db9086e54">&#9670;&nbsp;</a></span>generateCroPaCLCMVmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateCroPaCLCMVmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>regPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(EXPERIMENTAL) Generates a powermap utilising the CroPaC LCMV post-filter described in [1] </p>
<p>The spatial post-filter is estimated for all directions on the grid, and is used to supress reverb/noise interference that may be present in an MVDR map. Unlike in the paper, the second column for the contraints 'A', is Y.*diag(Cx), rather than utilising a maximum energy beamformer. The post- filters are then applied to the MVDR powermap map derived in the sherical harmonic domain, rather than an MVDR beamformer generated directly in the microphone array signal domain, like in the paper. Otherwise, the algorithm is the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covariance matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regPar</td><td>Regularisation parameter, for diagonal loading of Cx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Parameter controlling how harsh CroPaC is applied, 0..1; 0: fully CroPaC, 1: fully MVDR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting CroPaC LCMV powermap; nGrid_dirs x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Delikaris-Manias, S., Vilkamo, J., &amp; Pulkki, V. (2016). Signal- dependent spatial filtering based on weighted-orthogonal beamformers in the spherical harmonic domain. IEEE/ACM Transactions on Audio, Speech and Language Processing (TASLP), 24(9), 1507-1519. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01552">1552</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga08d3bc0f9e750716e3fb73c1c3aafe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d3bc0f9e750716e3fb73c1c3aafe6e">&#9670;&nbsp;</a></span>generateMinNormMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMinNormMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logScaleFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an activity-map based on the sub-space minimum-norm (MinNorm) method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covariance matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSources</td><td>Number of sources present in sound scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logScaleFlag</td><td>'1' log(pmap), '0' pmap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MinNorm pseudo-spectrum; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01704">1704</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga9c430bacc593f41dbc7b0b1ba6c912cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c430bacc593f41dbc7b0b1ba6c912cd">&#9670;&nbsp;</a></span>generateMUSICmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMUSICmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logScaleFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an activity-map based on the sub-space multiple-signal classification (MUSIC) method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covariance matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSources</td><td>Number of sources present in sound scene </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logScaleFlag</td><td>'1' log(pmap), '0' pmap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MUSIC pseudo-spectrum; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01656">1656</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga0a623080053b63c3a918485dcba3e084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a623080053b63c3a918485dcba3e084">&#9670;&nbsp;</a></span>generateMVDRmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generateMVDRmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>regPar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>w_MVDR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a powermap based on the energy of adaptive Minimum-Variance Distortion-less Response (MVDR) beamformers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covariance matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regPar</td><td>Regularisation parameter, for diagonal loading of Cx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting MVDR powermap; nGrid_dirs x 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w_MVDR</td><td>(Optional) weights will be copied to this, unless it's NULL; FLAT: nSH x nGrid_dirs || NULL </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01486">1486</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gac6b1194ee375caef234c1302fddce718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b1194ee375caef234c1302fddce718">&#9670;&nbsp;</a></span>generatePWDmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generatePWDmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGrid_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a powermap based on the energy of a plane-wave decomposition (PWD) (i.e. </p>
<p>hyper-cardioid) beamformers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Analysis order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Correlation/covariance matrix; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y_grid</td><td>Steering vectors for each grid direcionts; FLAT: (order+1)^2 x nGrid_dirs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nGrid_dirs</td><td>Number of grid directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pmap</td><td>Resulting PWD powermap; nGrid_dirs x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01444">1444</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga4f83c48c3d7c7f20726512e0495cf4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f83c48c3d7c7f20726512e0495cf4b9">&#9670;&nbsp;</a></span>getSHcomplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHcomplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes complex-valued spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The real spherical harmonics are computed WITH the 1/sqrt(4*pi) term. This function employs <a class="el" href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1].">unnorm_legendreP()</a> and double precision.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes [azi, inclination] convention! Note that one may convert from elevation, with: [azi, pi/2-elev].</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000012">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#ad64c17df200f732d064245776199dee0" title="Testing the orthogonality of the getSHcomplex() function.">test__getSHcomplex()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00330">330</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gadab8bc47f1068e8edd58e5d5c93a3fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab8bc47f1068e8edd58e5d5c93a3fa4">&#9670;&nbsp;</a></span>getSHreal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHreal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes real-valued spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The spherical harmonic values are computed WITH the 1/sqrt(4*pi) term. Compared to <a class="el" href="group___s_h.html#gabf4d86ed458c9fcdb13065c7e2f4c436" title="Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.">getSHreal_recur()</a>, this function uses <a class="el" href="group___s_h.html#ga1ff15ddf9e257b1f185421568ef349dd" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1].">unnorm_legendreP()</a> and double precision, so is more suitable for being computed in an initialisation stage. This version is indeed slower, but more precise (especially for high orders).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes [azi, inclination] convention! Note that one may convert from elevation, with: [azi, pi/2-elev].</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000010">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a26eb1d422499252a5d6ce0fa72b0df8a" title="Testing the orthogonality of the getSHreal() function.">test__getSHreal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00187">187</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gabf4d86ed458c9fcdb13065c7e2f4c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4d86ed458c9fcdb13065c7e2f4c436">&#9670;&nbsp;</a></span>getSHreal_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHreal_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes real-valued spherical harmonics [1] for each given direction on the unit sphere. </p>
<p>The real spherical harmonics are computed WITH the 1/sqrt(4*pi) term. Compared to <a class="el" href="group___s_h.html#gadab8bc47f1068e8edd58e5d5c93a3fa4" title="Computes real-valued spherical harmonics [1] for each given direction on the unit sphere.">getSHreal()</a>, this function uses <a class="el" href="group___s_h.html#ga3851842c7f6c520c3f645f0ae686443c" title="Calculates unnormalised Legendre polynomials up to order N, for all values in vector x.">unnorm_legendreP_recur()</a> and single precision, so is more suitable for being computed in a real-time loop. It sacrifices some precision, and numerical error propogates through the recursion, but it is much faster.</p>
<p>The function also uses static memory buffers for single direction and up to 7th order, which speeds things up considerably for such use cases.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes [azi, inclination] convention! Note that one may convert from elevation, with: [azi, pi/2-elev].</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000011">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a180a86ce81b6ee9cdd6e9c1390045632" title="Testing that the getSHreal_recur() function is somewhat numerically identical to the full-fat getSHre...">test__getSHreal_recur()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirs_rad</td><td>Directions on the sphere [azi, INCLINATION] convention, in RADIANS; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The SH weights [WITH the 1/sqrt(4*pi)]; FLAT: (order+1)^2 x nDirs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Rafaely, B. (2015). Fundamentals of spherical array processing (Vol. 8). Berlin: Springer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00252">252</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gabb0681d04a190b7e1fe3d362f301f63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb0681d04a190b7e1fe3d362f301f63e">&#9670;&nbsp;</a></span>getSHrotMtxReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSHrotMtxReal </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>R</em>[3][3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>RotMtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a real-valued spherical harmonic rotation matrix [1] based on a 3x3 rotation matrix (see <a class="el" href="group___utilities.html#ga2e80b68f78c7c6317073e603b6ed0b78" title="Constructs a 3x3 rotation matrix based on a quaternion.">quaternion2rotationMatrix()</a>, <a class="el" href="group___utilities.html#ga19a8e982f11eb0deaade1383781e179b" title="Constructs a 3x3 rotation matrix from the Euler angles.">euler2rotationMatrix()</a>) </p>
<p>The rotation should then be applied as: </p><div class="fragment"><div class="line">outSig = RotMtx * inSig; % where inSig/outSig are: (L+1)^2 x signalLength</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The normalisation convention does not matter, since only dipoles are used to rotate dipoles, quadrapoles to rotate quadrapoles etc. So any order-dependent scaling is irrelevant. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The resulting rotation matrix should be applied to signals which follow the ACN channel ordering convention!</dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000015">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a8a5477ba3d6118be1ea4b962c573c9f9" title="Testing the spherical harmonic rotation matrix function getSHrotMtxReal()">test__getSHrotMtxReal()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>The 3x3 rotation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RotMtx</td><td>SH domain rotation matrix; FLAT: (L+1)^2 x (L+1)^2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Ivanic, J., Ruedenberg, K. (1998). Rotation Matrices for Real Spherical Harmonics. Direct Determination by Recursion Page: Additions and Corrections. Journal of Physical Chemistry A, 102(45), 9099?9100. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00476">476</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gae1bf4d927842a9c97771801f2483b32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1bf4d927842a9c97771801f2483b32d">&#9670;&nbsp;</a></span>real2complexSHMtx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void real2complexSHMtx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>T_r2c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a real to complex spherical harmonic transform matrix. </p>
<p>Computes the unitary transformation matrix T_r2c the expresses the complex spherical harmonics with respect to the real harmonics, so that y_N = T_r2c * r_N, where r_N and y_N are the real and complex SH vectors, respectively.</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000014">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a073d3c584fce77cc00fd2d11237436d9" title="Testing the real to complex spherical harmonic conversion, using getSHcomplex() as the reference.">test__real2complexSHMtx()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T_r2c</td><td>Transformation matrix for real-&gt;complex; FLAT: (order+1)^2 x (order+1)^2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00413">413</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga266a06c6c96240add2d3ab171d89925d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga266a06c6c96240add2d3ab171d89925d">&#9670;&nbsp;</a></span>rotateAxisCoeffsComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateAxisCoeffsComplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>c_nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for a rotated axisymmetric pattern (COMPLEX) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c_n</td><td>Coefficients describing a rotationally symmetric pattern order N, expressed as a sum of spherical harmonics of degree m=0; (N+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_0</td><td>POLAR rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_0</td><td>Azimuthal rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c_nm</td><td>Coefficients of rotated pattern expressed as a sum of SHs; (N+1)^2 x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00846">846</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga824b11467b1f54b0725264b256f6a193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824b11467b1f54b0725264b256f6a193">&#9670;&nbsp;</a></span>rotateAxisCoeffsReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotateAxisCoeffsReal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>phi_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>c_nm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates spherical coefficients for a rotated axisymmetric pattern (REAL) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Order of spherical harmonic expansion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c_n</td><td>Coefficients describing a rotationally symmetric pattern order N, expressed as a sum of spherical harmonics of degree m=0; (N+1) x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_0</td><td>POLAR rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_0</td><td>Azimuthal rotation for the pattern, in RADIANS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c_nm</td><td>Coefficients of rotated pattern expressed as a sum of SHs; (N+1)^2 x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00826">826</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gaa5203b16cf67ef27b422078d20618863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5203b16cf67ef27b422078d20618863">&#9670;&nbsp;</a></span>simulateCylArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateCylArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a cylindrical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the cylinder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_dirs_deg</td><td>Spherical coords of the plane waves in DEGREES, [azi ELEV]; FLAT: N_srcs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_srcs</td><td>Number sources (DoAs of plane waves) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H_array</td><td>Simulated array response for each plane wave; FLAT: nBands x N_sensors x N_srcs </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l02145">2145</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gab4fe5085d4cc6223772f6e49ef74f355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4fe5085d4cc6223772f6e49ef74f355">&#9670;&nbsp;</a></span>simulateSphArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void simulateSphArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>H_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulates a spherical microphone array, returning the transfer functions for each (plane wave) source direction on the surface of the sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius, set to NULL if not needed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_dirs_deg</td><td>Spherical coords of the plane waves in DEGREES, [azi ELEV]; FLAT: N_srcs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_srcs</td><td>Number sources (DoAs of plane waves) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H_array</td><td>Simulated array response for each plane wave; FLAT: nBands x N_sensors x N_srcs </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l02197">2197</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga898eab67c2144d794201bbc80c2c6aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898eab67c2144d794201bbc80c2c6aa2">&#9670;&nbsp;</a></span>sphArrayAliasLim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sphArrayAliasLim </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a simple estimate of the spatial aliasing limit (the kR = maxN rule) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Array radius, meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Speed of sound, m/s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxN</td><td>Order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spatial aliasing limit estimate, in Hz </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01830">1830</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga9774e448be3d0caf15ce45077d0d5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9774e448be3d0caf15ce45077d0d5ebe">&#9670;&nbsp;</a></span>sphArrayNoiseThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphArrayNoiseThreshold </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nsensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxG_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>f_lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the frequencies (per order), at which the noise of a SHT of a SMA exceeds a specified maximum level. </p>
<p>Computes the frequencies that the noise in the output channels of a spherical microphone array (SMA), after performing the spherical harmonic transform (SHT) and equalisation of the output signals, reaches a certain user-defined threshold maxG_db. The frequencies are computed only at the lower range of each order, where its response decays rapidly, ignoring for example the nulls of an open array at the higher frequencies. The estimation of the limits are based on a linear approximation of the log-log response found e.g. in [1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxN</td><td>Maximum order of the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nsensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Mic radius, meters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Speed of sound, m/s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxG_db</td><td>Max allowed amplification for the noise level, maxG_db = 20*log10(maxG) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_lim</td><td>Noise limit estimate; (maxN+1) x 1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] Politis, A., Vilkamo, J., &amp; Pulkki, V. (2015). Sector-based parametric sound field reproduction in the spherical harmonic domain. IEEE Journal of Selected Topics in Signal Processing, 9(5), 852-866. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01840">1840</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gadbfb43c7f737a1f030ebe471272e7c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbfb43c7f737a1f030ebe471272e7c04">&#9670;&nbsp;</a></span>sphDiffCohMtxTheory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphDiffCohMtxTheory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>sensor_dirs_rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>M_diffcoh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the theoretical diffuse coherence matrix for a spherical array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor_dirs_rad</td><td>Spherical coords of the sensors in RADIANS, [azi ELEV]; FLAT: N_sensors x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_sensors</td><td>Number of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*sensor_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M_diffcoh</td><td>Theoretical diffuse coherence matrix per frequency; FLAT: N_sensors x N_sensors x nBands </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l02068">2068</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga37dbabb094421f7d62d3bdf7639994e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37dbabb094421f7d62d3bdf7639994e4">&#9670;&nbsp;</a></span>sphESPRIT_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphESPRIT_create </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phESPRIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the spherical harmonic domain ESPRIT-based direction of arrival estimator. </p>
<p>The ESPRIT method (in this case, using spherical harmonic input signals) returns the analysed DoAs directly; i.e. without any grid searching/ scanning (like e.g. MUSIC requires...). The DoA estimates are therefore continuous, i.e. not bound to any grid.</p>
<p>This particular implementation is is based on the "3-recurrence relationship" design, detailed in [1].</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000020">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#a70a6ae2e1c5ad450fac2422246c703b5" title="Testing the DoA estimation performance of sphESPRIT()">test__sphESPRIT()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phESPRIT</td><td>(&amp;) address of the ESPRIT DoA estimator handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Spherical harmonic input order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] B. Jo and J.-W. Choi, "Parametric direction-of-arrival estimation
         with three recurrence relations of spherical harmonics," J. Acoust. Soc. Amer.,vol. 145, no. 1, pp. 480&ndash;488, Jan. 2019. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01211">1211</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gab2bf00932a6a3dc9e1b87fa0153f1f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bf00932a6a3dc9e1b87fa0153f1f55">&#9670;&nbsp;</a></span>sphESPRIT_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphESPRIT_destroy </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phESPRIT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of the spherical harmonic domain ESPRIT-based direction of arrival estimator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phESPRIT</td><td>(&amp;) address of the ESPRIT DoA estimator handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01283">1283</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga691b6b170ac22906adbc08c8b27a2418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga691b6b170ac22906adbc08c8b27a2418">&#9670;&nbsp;</a></span>sphESPRIT_estimateDirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphESPRIT_estimateDirs </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hESPRIT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src_dirs_rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimates the direction-of-arrival (DoA) based on the ESPRIT-based estimator, in the spherical harmonic domain. </p>
<dl class="section note"><dt>Note</dt><dd>The "signal subspace" refers to the first K eigenvectors of the spatial correlation matrix, after sorting them such that the eigenvalue are in descending order. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The number of sources (K) cannot exceed: order^2!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hESPRIT</td><td>The ESPRIT DoA estimator handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Us</td><td>Signal subspace; FLAT: (order+1)^2 x K </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>Number of sources </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">src_dirs_rad</td><td>Source directions, in radians; K x 2 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01330">1330</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga6c331fd73b56845ab0ecbf4b0d5fc640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c331fd73b56845ab0ecbf4b0d5fc640">&#9670;&nbsp;</a></span>sphModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b">ARRAY_CONSTRUCTION_TYPES</a>&#160;</td>
          <td class="paramname"><em>arrayType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for open/rigid spherical arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayType</td><td>See <a class="el" href="group___s_h.html#gaa2eb5bb4fefe6565eddd3f6ca862ba6b" title="Microphone/Hydrophone array construction types.">ARRAY_CONSTRUCTION_TYPES</a> enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Only for directional (open) arrays, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01868">1868</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga36a05324e0f65f141dc8df7578a1521d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a05324e0f65f141dc8df7578a1521d">&#9670;&nbsp;</a></span>sphMUSIC_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphMUSIC_compute </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hMUSIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSrcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>P_music</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>peak_inds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a pseudo-spectrum based on the MUSIC algorithm in the spherical harmonic domain; optionally returning the grid indices corresponding to the N highest peaks (N=nSrcs) </p>
<dl class="section warning"><dt>Warning</dt><dd>The number of sources should not exceed: floor(nSH/2)!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hMUSIC</td><td>sphMUSIC handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vn</td><td>Noise subspace; FLAT: nSH x (nSH - nSrcs) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSrcs</td><td>Number of sources (or an estimate of the number of sources) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P_music</td><td>Pseudo-spectrum (set to NULL if not wanted); nDirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peak_inds</td><td>Indices corresponding to the "nSrcs" highest peaks in the pseudo-spectrum (set to NULL if not wanted); nSrcs x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01147">1147</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga5795da6a1c9ddc4e8da449c3dfc5da7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5795da6a1c9ddc4e8da449c3dfc5da7d">&#9670;&nbsp;</a></span>sphMUSIC_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphMUSIC_create </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phMUSIC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>grid_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the spherical harmonic domain MUSIC implementation, which may be used for computing pseudo-spectrums for visualisation/DoA estimation purposes. </p>
<dl class="section note"><dt>Note</dt><dd>Subspace approaches such as MUSIC can offer higher spatial resolution than beamforming approaches, such as the steered-response power (PWD), as long as the source signals are not correlated between them and are presented in a reverberant/diffuse sound. </dd></dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000019">Test:</a></b></dt><dd><a class="el" href="saf__test_8c.html#ada1afadc3ce01509670706830fec494e" title="Testing the DoA estimation performance of sphMUSIC()">test__sphMUSIC()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phMUSIC</td><td>(&amp;) address of the sphMUSIC handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Spherical harmonic input order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid_dirs_deg</td><td>Scanning grid directions; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of scanning directions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01080">1080</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga1d297fcc1391d5771694a2db578ad94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d297fcc1391d5771694a2db578ad94f">&#9670;&nbsp;</a></span>sphMUSIC_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphMUSIC_destroy </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phMUSIC</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of the spherical harmonic domain MUSIC implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phMUSIC</td><td>(&amp;) address of the sphMUSIC handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01126">1126</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga8ff25c089ba08c1fa24588ac2c3847d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ff25c089ba08c1fa24588ac2c3847d6">&#9670;&nbsp;</a></span>sphPWD_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphPWD_compute </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>hPWD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_complex *&#160;</td>
          <td class="paramname"><em>Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSrcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>P_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>peak_inds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a power-map based on determining the energy of hyper-cardioid beamformers; optionally, also returning the grid indices corresponding to the N highest peaks (N=nSrcs) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hPWD</td><td>sphPWD handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Cx</td><td>Signal covariance matrix; FLAT: nSH x nSH </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nSrcs</td><td>Number of sources (or an estimate of the number of sources), for the optional peak finding (peak_inds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P_map</td><td>Powermap (set to NULL if not wanted); nDirs x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peak_inds</td><td>Indices corresponding to the "nSrcs" highest peaks in the power-map (set to NULL if not wanted); nSrcs x 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01015">1015</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga2bf0a400072210fcc5613918008c03ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf0a400072210fcc5613918008c03ce">&#9670;&nbsp;</a></span>sphPWD_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphPWD_create </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phPWD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>grid_dirs_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDirs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of a spherical harmonic domain implementation of the steer-response power (SRP) approach for computing power-maps, which can then be used for sound-field visualisation/DoA estimation purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phPWD</td><td>(&amp;) address of the sphPWD handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Spherical harmonic input order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid_dirs_deg</td><td>Scanning grid directions; FLAT: nDirs x 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDirs</td><td>Number of scanning directions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00950">950</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga804a98cd6ebe9775cfe1447c9d2f24e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804a98cd6ebe9775cfe1447c9d2f24e8">&#9670;&nbsp;</a></span>sphPWD_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphPWD_destroy </td>
          <td>(</td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>phPWD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of the spherical harmonic domain PWD implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">phPWD</td><td>(&amp;) address of the sphPWD handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00995">995</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gaedc488e33c0239baebed8cd7aeabd8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc488e33c0239baebed8cd7aeabd8a7">&#9670;&nbsp;</a></span>sphScattererDirModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphScattererDirModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dirCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for a rigid spherical scatterer with directional sensors. </p>
<p>Assumes all sensors are placed the same distance from the scatterer, w.r.t. the origin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirCoeff</td><td>Directivity coefficient, 1: omni, 0.5: card, 0:dipole </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l02001">2001</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="gadc74c9714841c3f48974fe10e6485eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc74c9714841c3f48974fe10e6485eea">&#9670;&nbsp;</a></span>sphScattererModalCoeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sphScattererModalCoeffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double_complex *&#160;</td>
          <td class="paramname"><em>b_N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the modal coefficients for a rigid spherical scatterer with omni-directional sensors. </p>
<p>Assumes all sensors are placed the same distance from the scatterer, w.r.t. the origin</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Max order (highest is ~30 given numerical precision) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kr</td><td>wavenumber*array_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kR</td><td>wavenumber*scatterer_radius; nBands x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBands</td><td>Number of frequency bands/bins </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b_N</td><td>Modal coefficients per kr and 0:order; FLAT: nBands x (order+1) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l01952">1952</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga1ff15ddf9e257b1f185421568ef349dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff15ddf9e257b1f185421568ef349dd">&#9670;&nbsp;</a></span>unnorm_legendreP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unnorm_legendreP </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates unnormalised Legendre polynomials up to order N, for all values in vector x [1]. </p>
<dl class="section note"><dt>Note</dt><dd>This includes the Condon-Shortley phase term. It is functionally identical to Matlab's legendre function (with default settings ['unnorm']).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Order of Legendre polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector of input values; lenX x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenX</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Resulting unnormalised Legendre values for each x value; FLAT: (n+1) x lenX</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>[1] M, Abramowitz., I.A. Stegun. (1965). "Handbook of Mathematical
         Functions: Chapter 8", Dover Publications. </dd></dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00050">50</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
<a id="ga3851842c7f6c520c3f645f0ae686443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3851842c7f6c520c3f645f0ae686443c">&#9670;&nbsp;</a></span>unnorm_legendreP_recur()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unnorm_legendreP_recur </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lenX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm_minus1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm_minus2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>Pnm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates unnormalised Legendre polynomials up to order N, for all values in vector x. </p>
<p>It uses a recursive approach, which makes it more suitable for computing the legendre values in a real-time loop.</p>
<dl class="section note"><dt>Note</dt><dd>This does NOT include the Condon-Shortley phase term.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Order of Legendre polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector of input values; lenX x 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenX</td><td>Number of input values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pnm_minus1</td><td>Previous Pnm, (not used for n=1); FLAT: (n+1) x lenX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Pnm_minus2</td><td>Previous previous Pnm, (not used for n=0); FLAT: (n+1) x lenX </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Pnm</td><td>Resulting unnormalised Legendre values for each x value; FLAT: (n+1) x lenX </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="saf__sh_8c_source.html#l00126">126</a> of file <a class="el" href="saf__sh_8c_source.html">saf_sh.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri May 21 2021 23:58:54 for Spatial_Audio_Framework by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
